{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/mongodb.ts"],"sourcesContent":["import { MongoClient, type Db } from \"mongodb\"\r\n\r\nlet cachedClient: MongoClient | null = null\r\nlet cachedDb: Db | null = null\r\n\r\nexport async function connectToDatabase() {\r\n  const mongoUri = process.env.MONGODB_URI\r\n\r\n  if (!mongoUri || mongoUri.includes(\"your_mongodb_connection_string\")) {\r\n    console.warn(\"[MongoDB] MongoDB URI not configured. Using mock mode for development.\")\r\n    // Return a mock object for development when no valid URI is provided\r\n    return {\r\n      client: null,\r\n      db: {\r\n        collection: () => ({\r\n          findOne: async () => null,\r\n          insertOne: async () => ({ insertedId: \"mock-id\" }),\r\n          updateOne: async () => ({}),\r\n          deleteOne: async () => ({}),\r\n          find: () => ({ toArray: async () => [] }),\r\n        }),\r\n      } as any,\r\n    }\r\n  }\r\n\r\n  if (cachedClient && cachedDb) {\r\n    return { client: cachedClient, db: cachedDb }\r\n  }\r\n\r\n  try {\r\n    const client = new MongoClient(mongoUri)\r\n    await client.connect()\r\n    const db = client.db(\"code-explorer\")\r\n\r\n    cachedClient = client\r\n    cachedDb = db\r\n\r\n    return { client, db }\r\n  } catch (error) {\r\n    console.error(\"Failed to connect to MongoDB:\", error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function closeDatabase() {\r\n  if (cachedClient) {\r\n    await cachedClient.close()\r\n    cachedClient = null\r\n    cachedDb = null\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,eAAmC;AACvC,IAAI,WAAsB;AAEnB,eAAe;IACpB,MAAM,WAAW,QAAQ,GAAG,CAAC,WAAW;IAExC,IAAI,CAAC,YAAY,SAAS,QAAQ,CAAC,mCAAmC;QACpE,QAAQ,IAAI,CAAC;QACb,qEAAqE;QACrE,OAAO;YACL,QAAQ;YACR,IAAI;gBACF,YAAY,IAAM,CAAC;wBACjB,SAAS,UAAY;wBACrB,WAAW,UAAY,CAAC;gCAAE,YAAY;4BAAU,CAAC;wBACjD,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,MAAM,IAAM,CAAC;gCAAE,SAAS,UAAY,EAAE;4BAAC,CAAC;oBAC1C,CAAC;YACH;QACF;IACF;IAEA,IAAI,gBAAgB,UAAU;QAC5B,OAAO;YAAE,QAAQ;YAAc,IAAI;QAAS;IAC9C;IAEA,IAAI;QACF,MAAM,SAAS,IAAI,sHAAW,CAAC;QAC/B,MAAM,OAAO,OAAO;QACpB,MAAM,KAAK,OAAO,EAAE,CAAC;QAErB,eAAe;QACf,WAAW;QAEX,OAAO;YAAE;YAAQ;QAAG;IACtB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM;IACR;AACF;AAEO,eAAe;IACpB,IAAI,cAAc;QAChB,MAAM,aAAa,KAAK;QACxB,eAAe;QACf,WAAW;IACb;AACF"}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/auth-config.ts"],"sourcesContent":["import { AuthOptions, User } from \"next-auth\"\r\nimport CredentialsProvider from \"next-auth/providers/credentials\"\r\nimport { connectToDatabase } from \"@/lib/mongodb\"Â \r\nimport bcrypt from \"bcryptjs\"\r\nimport { ObjectId } from \"mongodb\"Â \r\n\r\n// Note: Relying on the global 'User' type extended in next-auth.d.ts\r\n\r\n// Define the NextAuth options object\r\nexport const authOptions: AuthOptions = {\r\nÂ  // Use session strategy based on JWT (standard for stateless serverless functions)\r\nÂ  session: {\r\nÂ  Â  strategy: \"jwt\",\r\nÂ  },\r\nÂ Â \r\nÂ  providers: [\r\nÂ  Â  CredentialsProvider({\r\nÂ  Â  Â  name: \"Credentials\",\r\nÂ  Â  Â  credentials: {\r\nÂ  Â  Â  Â  email: { label: \"Email\", type: \"email\" },\r\nÂ  Â  Â  Â  password: { label: \"Password\", type: \"password\" },\r\nÂ  Â  Â  },\r\nÂ  Â  Â  // Explicitly define the return type as User | null (using the globally extended type)\r\nÂ  Â  Â  async authorize(credentials): Promise<User | null> {\r\nÂ  Â  Â  Â  if (!credentials) {\r\nÂ  Â  Â  Â  Â  return null\r\nÂ  Â  Â  Â  }\r\nÂ  Â  Â  Â  const { email, password } = credentials\r\n\r\nÂ  Â  Â  Â  try {\r\nÂ  Â  Â  Â  Â  const { db } = await connectToDatabase()\r\nÂ  Â  Â  Â  Â  const user = await db.collection(\"users\").findOne({ email })\r\n\r\nÂ  Â  Â  Â  Â  if (!user) {\r\nÂ  Â  Â  Â  Â  Â  console.error(\"Login failed: User not found for email:\", email)\r\nÂ  Â  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")Â \r\nÂ  Â  Â  Â  Â  }\r\n\r\nÂ  Â  Â  Â  Â  const isValid = await bcrypt.compare(password, user.password)\r\nÂ  Â  Â  Â  Â Â \r\nÂ  Â  Â  Â  Â  if (!isValid) {\r\nÂ  Â  Â  Â  Â  Â  console.error(\"Login failed: Invalid password for email:\", email)\r\nÂ  Â  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")\r\nÂ  Â  Â  Â  Â  }\r\nÂ  Â  Â  Â  Â Â \r\nÂ  Â  Â  Â  Â  // Return an object that matches the ExtendedUser interface structure.\r\nÂ  Â  Â  Â  Â  return {\r\nÂ  Â  Â  Â  Â  Â  id: user._id.toString(), // Must be a string\r\nÂ  Â  Â  Â  Â  Â  name: user.name as string, // Cast to string if needed\r\nÂ  Â  Â  Â  Â  Â  email: user.email as string, // Cast to string if needed\r\nÂ  Â  Â  Â  Â  Â  // ðŸ’¡ FIX 4: Use 'subscriptionPlan' instead of 'tier'\r\nÂ  Â  Â  Â  Â  Â  subscriptionPlan: user.subscriptionPlan || \"free\",Â \r\nÂ  Â  Â  Â  Â  } as User\r\nÂ  Â  Â  Â  } catch (e) {\r\nÂ  Â  Â  Â  Â  console.error(\"Error during authorization:\", e)\r\nÂ  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")Â \r\nÂ  Â  Â  Â  }\r\nÂ  Â  Â  },\r\nÂ  Â  }),\r\nÂ  ],\r\nÂ Â \r\nÂ  // Custom pages configuration to handle redirects\r\nÂ  pages: {\r\nÂ  Â  signIn: \"/login\",\r\nÂ  Â  error: \"/login\",Â \r\nÂ  },\r\n\r\nÂ  callbacks: {\r\nÂ  Â  // Add custom properties (id, subscriptionPlan) to the JWT\r\nÂ  Â  async jwt({ token, user, trigger, session }) {\r\nÂ  Â  Â  if (user) {\r\nÂ  Â  Â  Â  token.id = user.id\r\nÂ  Â  Â  Â  // ðŸ’¡ FIX 5: Use 'subscriptionPlan' instead of 'tier'\r\nÂ  Â  Â  Â  token.subscriptionPlan = (user as User).subscriptionPlan\r\nÂ  Â  Â  }\r\n\r\n      // ðŸ’¡ FIX 6: Handle session refresh triggered by update() call from client\r\n      if (trigger === \"update\" && session && (session as { subscriptionPlan?: string }).subscriptionPlan) {\r\n        // Update the token's subscriptionPlan with the new value from the update() payload\r\n        token.subscriptionPlan = (session as { subscriptionPlan: string }).subscriptionPlan\r\n      }\r\nÂ  Â  Â  return token\r\nÂ  Â  },\r\nÂ  Â  // Add custom properties (id, subscriptionPlan) to the session object exposed on the client\r\nÂ  Â  async session({ session, token }) {\r\nÂ  Â  Â  if (session.user) {\r\nÂ  Â  Â  Â  // @ts-ignore: Add custom properties to session.user\r\nÂ  Â  Â  Â  session.user.id = token.id\r\nÂ  Â  Â  Â  // ðŸ’¡ FIX 7: Use 'subscriptionPlan' instead of 'tier'\r\nÂ  Â  Â  Â  // @ts-ignore: Access token.subscriptionPlan\r\nÂ  Â  Â  Â  session.user.subscriptionPlan = token.subscriptionPlan\r\nÂ  Â  Â  }\r\nÂ  Â  Â  return session\r\nÂ  Â  },\r\nÂ  },\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAMO,MAAM,cAA2B;IACtC,kFAAkF;IAClF,SAAS;QACP,UAAU;IACZ;IAEA,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,sFAAsF;YACtF,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa;oBAChB,OAAO;gBACT;gBACA,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG;gBAE5B,IAAI;oBACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,IAAA,qIAAiB;oBACtC,MAAM,OAAO,MAAM,GAAG,UAAU,CAAC,SAAS,OAAO,CAAC;wBAAE;oBAAM;oBAE1D,IAAI,CAAC,MAAM;wBACT,QAAQ,KAAK,CAAC,2CAA2C;wBACzD,MAAM,IAAI,MAAM;oBAClB;oBAEA,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;oBAE5D,IAAI,CAAC,SAAS;wBACZ,QAAQ,KAAK,CAAC,6CAA6C;wBAC3D,MAAM,IAAI,MAAM;oBAClB;oBAEA,sEAAsE;oBACtE,OAAO;wBACL,IAAI,KAAK,GAAG,CAAC,QAAQ;wBACrB,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;wBACjB,qDAAqD;wBACrD,kBAAkB,KAAK,gBAAgB,IAAI;oBAC7C;gBACF,EAAE,OAAO,GAAG;oBACV,QAAQ,KAAK,CAAC,+BAA+B;oBAC7C,MAAM,IAAI,MAAM;gBAClB;YACF;QACF;KACD;IAED,iDAAiD;IACjD,OAAO;QACL,QAAQ;QACR,OAAO;IACT;IAEA,WAAW;QACT,0DAA0D;QAC1D,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACzC,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,qDAAqD;gBACrD,MAAM,gBAAgB,GAAG,AAAC,KAAc,gBAAgB;YAC1D;YAEA,0EAA0E;YAC1E,IAAI,YAAY,YAAY,WAAW,AAAC,QAA0C,gBAAgB,EAAE;gBAClG,mFAAmF;gBACnF,MAAM,gBAAgB,GAAG,AAAC,QAAyC,gBAAgB;YACrF;YACA,OAAO;QACT;QACA,2FAA2F;QAC3F,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,oDAAoD;gBACpD,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,qDAAqD;gBACrD,4CAA4C;gBAC5C,QAAQ,IAAI,CAAC,gBAAgB,GAAG,MAAM,gBAAgB;YACxD;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/app/api/share/generate-pin/route.ts"],"sourcesContent":["import { connectToDatabase } from \"@/lib/mongodb\"\r\nimport { type NextRequest, NextResponse } from \"next/server\"\r\nimport { getServerSession } from \"next-auth/next\"\r\nimport { authOptions } from \"@/lib/auth-config\"\r\n\r\n/**\r\n * Generates a unique 4-digit PIN for sharing.\r\n */\r\nfunction generatePin(): string {\r\n  // Generate a random 4-digit number (1000 to 9999)\r\n  return Math.floor(1000 + Math.random() * 9000).toString()\r\n}\r\n\r\n/**\r\n * Handles the request to generate a shareable PIN and store the file data.\r\n */\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return NextResponse.json({ error: \"Authentication required\" }, { status: 401 })\r\n    }\r\n\r\n    // Expecting an array of file objects from the request body.\r\n    const { files } = await request.json()\r\n\r\n    if (!files || !Array.isArray(files) || files.length === 0) {\r\n      return NextResponse.json({ error: \"No files to share\" }, { status: 400 })\r\n    }\r\n\r\n    // Sanitize the files array to ensure essential fields are present before saving\r\n    const validFilesToStore = files.map((file: any) => ({\r\n        path: typeof file.path === 'string' ? file.path : 'unknown_path',\r\n        name: typeof file.name === 'string' ? file.name : 'unknown_file',\r\n        // Content must be included here for the download API to work later\r\n        content: typeof file.content === 'string' ? file.content : '', \r\n    })).filter((file: any) => file.name !== 'unknown_file') // Filter out files that didn't even have a name\r\n\r\n    if (validFilesToStore.length === 0) {\r\n        return NextResponse.json({ error: \"No valid file data provided for sharing\" }, { status: 400 })\r\n    }\r\n\r\n    const { db } = await connectToDatabase()\r\n    let pin = \"\"\r\n    let pinExists = true\r\n    \r\n    // Ensure the generated PIN is unique\r\n    while (pinExists) {\r\n        pin = generatePin()\r\n        // Only consider pins that haven't expired yet\r\n        const existingPin = await db.collection(\"shared_pins\").findOne({ \r\n            pin, \r\n            expiresAt: { $gt: new Date() } \r\n        })\r\n        if (!existingPin) {\r\n            pinExists = false\r\n        }\r\n    }\r\n\r\n    // Define expiration 7 days from now\r\n    const expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 7)\r\n\r\n    // Store shared files with PIN\r\n    const result = await db.collection(\"shared_pins\").insertOne({\r\n      pin,\r\n      userId: session.user.id,\r\n      files: validFilesToStore, // Store sanitized file data\r\n      expiresAt: expiresAt, \r\n      createdAt: new Date(),\r\n    })\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      pin,\r\n      shareId: result.insertedId,\r\n      expiresAt: expiresAt.toISOString(),\r\n    })\r\n  } catch (error) {\r\n    console.error(\"Share generation error:\", error)\r\n    return NextResponse.json({ error: \"Failed to generate share PIN\" }, { status: 500 })\r\n  }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;CAEC,GACD,SAAS;IACP,kDAAkD;IAClD,OAAO,KAAK,KAAK,CAAC,OAAO,KAAK,MAAM,KAAK,MAAM,QAAQ;AACzD;AAKO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,UAAU,MAAM,IAAA,mKAAgB,EAAC,sIAAW;QAClD,IAAI,CAAC,SAAS,MAAM,IAAI;YACtB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QAEA,4DAA4D;QAC5D,MAAM,EAAE,KAAK,EAAE,GAAG,MAAM,QAAQ,IAAI;QAEpC,IAAI,CAAC,SAAS,CAAC,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,KAAK,GAAG;YACzD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA,gFAAgF;QAChF,MAAM,oBAAoB,MAAM,GAAG,CAAC,CAAC,OAAc,CAAC;gBAChD,MAAM,OAAO,KAAK,IAAI,KAAK,WAAW,KAAK,IAAI,GAAG;gBAClD,MAAM,OAAO,KAAK,IAAI,KAAK,WAAW,KAAK,IAAI,GAAG;gBAClD,mEAAmE;gBACnE,SAAS,OAAO,KAAK,OAAO,KAAK,WAAW,KAAK,OAAO,GAAG;YAC/D,CAAC,GAAG,MAAM,CAAC,CAAC,OAAc,KAAK,IAAI,KAAK,gBAAgB,gDAAgD;;QAExG,IAAI,kBAAkB,MAAM,KAAK,GAAG;YAChC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0C,GAAG;gBAAE,QAAQ;YAAI;QACjG;QAEA,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,IAAA,qIAAiB;QACtC,IAAI,MAAM;QACV,IAAI,YAAY;QAEhB,qCAAqC;QACrC,MAAO,UAAW;YACd,MAAM;YACN,8CAA8C;YAC9C,MAAM,cAAc,MAAM,GAAG,UAAU,CAAC,eAAe,OAAO,CAAC;gBAC3D;gBACA,WAAW;oBAAE,KAAK,IAAI;gBAAO;YACjC;YACA,IAAI,CAAC,aAAa;gBACd,YAAY;YAChB;QACJ;QAEA,oCAAoC;QACpC,MAAM,YAAY,IAAI,KAAK,KAAK,GAAG,KAAK,OAAO,KAAK,KAAK,KAAK;QAE9D,8BAA8B;QAC9B,MAAM,SAAS,MAAM,GAAG,UAAU,CAAC,eAAe,SAAS,CAAC;YAC1D;YACA,QAAQ,QAAQ,IAAI,CAAC,EAAE;YACvB,OAAO;YACP,WAAW;YACX,WAAW,IAAI;QACjB;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT;YACA,SAAS,OAAO,UAAU;YAC1B,WAAW,UAAU,WAAW;QAClC;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2BAA2B;QACzC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA+B,GAAG;YAAE,QAAQ;QAAI;IACpF;AACF"}}]
}