{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/mongodb.ts"],"sourcesContent":["import { MongoClient, type Db } from \"mongodb\"\r\n\r\nlet cachedClient: MongoClient | null = null\r\nlet cachedDb: Db | null = null\r\n\r\nexport async function connectToDatabase() {\r\n  const mongoUri = process.env.MONGODB_URI\r\n\r\n  if (!mongoUri || mongoUri.includes(\"your_mongodb_connection_string\")) {\r\n    console.warn(\"[MongoDB] MongoDB URI not configured. Using mock mode for development.\")\r\n    // Return a mock object for development when no valid URI is provided\r\n    return {\r\n      client: null,\r\n      db: {\r\n        collection: () => ({\r\n          findOne: async () => null,\r\n          insertOne: async () => ({ insertedId: \"mock-id\" }),\r\n          updateOne: async () => ({}),\r\n          deleteOne: async () => ({}),\r\n          find: () => ({ toArray: async () => [] }),\r\n        }),\r\n      } as any,\r\n    }\r\n  }\r\n\r\n  if (cachedClient && cachedDb) {\r\n    return { client: cachedClient, db: cachedDb }\r\n  }\r\n\r\n  try {\r\n    const client = new MongoClient(mongoUri)\r\n    await client.connect()\r\n    const db = client.db(\"code-explorer\")\r\n\r\n    cachedClient = client\r\n    cachedDb = db\r\n\r\n    return { client, db }\r\n  } catch (error) {\r\n    console.error(\"Failed to connect to MongoDB:\", error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function closeDatabase() {\r\n  if (cachedClient) {\r\n    await cachedClient.close()\r\n    cachedClient = null\r\n    cachedDb = null\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,eAAmC;AACvC,IAAI,WAAsB;AAEnB,eAAe;IACpB,MAAM,WAAW,QAAQ,GAAG,CAAC,WAAW;IAExC,IAAI,CAAC,YAAY,SAAS,QAAQ,CAAC,mCAAmC;QACpE,QAAQ,IAAI,CAAC;QACb,qEAAqE;QACrE,OAAO;YACL,QAAQ;YACR,IAAI;gBACF,YAAY,IAAM,CAAC;wBACjB,SAAS,UAAY;wBACrB,WAAW,UAAY,CAAC;gCAAE,YAAY;4BAAU,CAAC;wBACjD,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,MAAM,IAAM,CAAC;gCAAE,SAAS,UAAY,EAAE;4BAAC,CAAC;oBAC1C,CAAC;YACH;QACF;IACF;IAEA,IAAI,gBAAgB,UAAU;QAC5B,OAAO;YAAE,QAAQ;YAAc,IAAI;QAAS;IAC9C;IAEA,IAAI;QACF,MAAM,SAAS,IAAI,sHAAW,CAAC;QAC/B,MAAM,OAAO,OAAO;QACpB,MAAM,KAAK,OAAO,EAAE,CAAC;QAErB,eAAe;QACf,WAAW;QAEX,OAAO;YAAE;YAAQ;QAAG;IACtB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM;IACR;AACF;AAEO,eAAe;IACpB,IAAI,cAAc;QAChB,MAAM,aAAa,KAAK;QACxB,eAAe;QACf,WAAW;IACb;AACF"}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/auth-config.ts"],"sourcesContent":["import { AuthOptions, User } from \"next-auth\"\r\nimport CredentialsProvider from \"next-auth/providers/credentials\"\r\nimport { connectToDatabase } from \"@/lib/mongodb\" \r\nimport bcrypt from \"bcryptjs\"\r\nimport { ObjectId } from \"mongodb\" \r\n\r\n// --- Custom Types ---\r\n// Define a type that extends the default NextAuth User type to include your custom properties (like tier)\r\n// This is necessary to satisfy the TypeScript compiler in the authorize function.\r\ninterface ExtendedUser extends User {\r\n  tier: string; // Add your custom property here\r\n}\r\n\r\n// Define the NextAuth options object\r\nexport const authOptions: AuthOptions = {\r\n  // Use session strategy based on JWT (standard for stateless serverless functions)\r\n  session: {\r\n    strategy: \"jwt\",\r\n  },\r\n  \r\n  providers: [\r\n    CredentialsProvider({\r\n      name: \"Credentials\",\r\n      credentials: {\r\n        email: { label: \"Email\", type: \"email\" },\r\n        password: { label: \"Password\", type: \"password\" },\r\n      },\r\n      // Explicitly define the return type as ExtendedUser | null\r\n      async authorize(credentials): Promise<ExtendedUser | null> {\r\n        if (!credentials) {\r\n          return null\r\n        }\r\n        const { email, password } = credentials\r\n\r\n        try {\r\n          const { db } = await connectToDatabase()\r\n          const user = await db.collection(\"users\").findOne({ email })\r\n\r\n          if (!user) {\r\n            console.error(\"Login failed: User not found for email:\", email)\r\n            // Use throw new Error for NextAuth to handle error messaging on the sign-in page\r\n            throw new Error(\"Invalid credentials\") \r\n          }\r\n\r\n          const isValid = await bcrypt.compare(password, user.password)\r\n          \r\n          if (!isValid) {\r\n            console.error(\"Login failed: Invalid password for email:\", email)\r\n            throw new Error(\"Invalid credentials\")\r\n          }\r\n          \r\n          // Return an object that matches the ExtendedUser interface structure.\r\n          return {\r\n            id: user._id.toString(), // Must be a string\r\n            name: user.name as string, // Cast to string if needed\r\n            email: user.email as string, // Cast to string if needed\r\n            // Correctly assign the custom 'tier' property\r\n            tier: user.subscriptionPlan || \"free\", \r\n          } as ExtendedUser\r\n        } catch (e) {\r\n          console.error(\"Error during authorization:\", e)\r\n          throw new Error(\"Invalid credentials\") \r\n        }\r\n      },\r\n    }),\r\n  ],\r\n  \r\n  // Custom pages configuration to handle redirects\r\n  pages: {\r\n    signIn: \"/login\",\r\n    error: \"/login\", \r\n  },\r\n\r\n  callbacks: {\r\n    // Add custom properties (id, tier) to the JWT\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        // user is of type ExtendedUser here\r\n        token.id = user.id\r\n        // @ts-ignore: Access the custom property 'tier' added in authorize\r\n        token.tier = (user as ExtendedUser).tier\r\n      }\r\n      return token\r\n    },\r\n    // Add custom properties (id, tier) to the session object exposed on the client\r\n    async session({ session, token }) {\r\n      if (session.user) {\r\n        // @ts-ignore: Add custom properties to session.user\r\n        session.user.id = token.id\r\n        // @ts-ignore: Add custom properties to session.user\r\n        session.user.tier = token.tier\r\n      }\r\n      return session\r\n    },\r\n  },\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAWO,MAAM,cAA2B;IACtC,kFAAkF;IAClF,SAAS;QACP,UAAU;IACZ;IAEA,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,2DAA2D;YAC3D,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa;oBAChB,OAAO;gBACT;gBACA,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG;gBAE5B,IAAI;oBACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,IAAA,qIAAiB;oBACtC,MAAM,OAAO,MAAM,GAAG,UAAU,CAAC,SAAS,OAAO,CAAC;wBAAE;oBAAM;oBAE1D,IAAI,CAAC,MAAM;wBACT,QAAQ,KAAK,CAAC,2CAA2C;wBACzD,iFAAiF;wBACjF,MAAM,IAAI,MAAM;oBAClB;oBAEA,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;oBAE5D,IAAI,CAAC,SAAS;wBACZ,QAAQ,KAAK,CAAC,6CAA6C;wBAC3D,MAAM,IAAI,MAAM;oBAClB;oBAEA,sEAAsE;oBACtE,OAAO;wBACL,IAAI,KAAK,GAAG,CAAC,QAAQ;wBACrB,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;wBACjB,8CAA8C;wBAC9C,MAAM,KAAK,gBAAgB,IAAI;oBACjC;gBACF,EAAE,OAAO,GAAG;oBACV,QAAQ,KAAK,CAAC,+BAA+B;oBAC7C,MAAM,IAAI,MAAM;gBAClB;YACF;QACF;KACD;IAED,iDAAiD;IACjD,OAAO;QACL,QAAQ;QACR,OAAO;IACT;IAEA,WAAW;QACT,8CAA8C;QAC9C,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,oCAAoC;gBACpC,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,mEAAmE;gBACnE,MAAM,IAAI,GAAG,AAAC,KAAsB,IAAI;YAC1C;YACA,OAAO;QACT;QACA,+EAA+E;QAC/E,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,oDAAoD;gBACpD,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,oDAAoD;gBACpD,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAChC;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/tier-limits.ts"],"sourcesContent":["export const TIER_LIMITS = {\r\n  anonymous: {\r\n    maxFilesPerZip: 100,\r\n    canDownloadIndividual: false,\r\n    canDownloadZip: false,\r\n    canSave: false,\r\n    maxSavedZips: 0,\r\n    maxDownloadsPerSession: 0,\r\n  },\r\n  free: {\r\n    maxFilesPerZip: 200,\r\n    canDownloadIndividual: true,\r\n    canDownloadZip: true,\r\n    canSave: false,\r\n    maxSavedZips: 0,\r\n    maxDownloadsPerSession: 10,\r\n  },\r\n  monthly: {\r\n    maxFilesPerZip: Number.POSITIVE_INFINITY,\r\n    canDownloadIndividual: true,\r\n    canDownloadZip: true,\r\n    canSave: true,\r\n    maxSavedZips: 5,\r\n    maxDownloadsPerSession: Number.POSITIVE_INFINITY,\r\n  },\r\n  yearly: {\r\n    maxFilesPerZip: Number.POSITIVE_INFINITY,\r\n    canDownloadIndividual: true,\r\n    canDownloadZip: true,\r\n    canSave: true,\r\n    maxSavedZips: 15,\r\n    maxDownloadsPerSession: Number.POSITIVE_INFINITY,\r\n  },\r\n} as const\r\n"],"names":[],"mappings":";;;;AAAO,MAAM,cAAc;IACzB,WAAW;QACT,gBAAgB;QAChB,uBAAuB;QACvB,gBAAgB;QAChB,SAAS;QACT,cAAc;QACd,wBAAwB;IAC1B;IACA,MAAM;QACJ,gBAAgB;QAChB,uBAAuB;QACvB,gBAAgB;QAChB,SAAS;QACT,cAAc;QACd,wBAAwB;IAC1B;IACA,SAAS;QACP,gBAAgB,OAAO,iBAAiB;QACxC,uBAAuB;QACvB,gBAAgB;QAChB,SAAS;QACT,cAAc;QACd,wBAAwB,OAAO,iBAAiB;IAClD;IACA,QAAQ;QACN,gBAAgB,OAAO,iBAAiB;QACxC,uBAAuB;QACvB,gBAAgB;QAChB,SAAS;QACT,cAAc;QACd,wBAAwB,OAAO,iBAAiB;IAClD;AACF"}},
    {"offset": {"line": 320, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/app/api/files/download/route.ts"],"sourcesContent":["import { connectToDatabase } from \"@/lib/mongodb\"\r\nimport { type NextRequest, NextResponse } from \"next/server\"\r\nimport { getServerSession } from \"next-auth/next\"\r\nimport { authOptions } from \"@/lib/auth-config\"\r\nimport JSZip from \"jszip\"\r\n// Assuming you have a file at this path with the TIER_LIMITS object\r\nimport { TIER_LIMITS } from \"@/lib/tier-limits\" \r\nimport { ObjectId } from \"mongodb\"\r\n\r\n// Define allowed tiers for validation\r\ntype AllowedTiers = \"anonymous\" | \"free\" | \"monthly\" | \"yearly\"\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    // Note: getServerSession returns null if not authenticated\r\n    const session = await getServerSession(authOptions)\r\n    \r\n    // Deconstruct body, including the userTier passed from the client\r\n    const body = await request.json()\r\n    const { sessionId, files, downloadType, userTier: clientUserTier } = body\r\n    \r\n    // Determine the user's tier based on client hint or default logic\r\n    const effectiveTier = (TIER_LIMITS as Record<string, any>).hasOwnProperty(clientUserTier)\r\n      ? clientUserTier as AllowedTiers\r\n      : session ? \"free\" : \"anonymous\"\r\n      \r\n    // Assuming TIER_LIMITS is structured correctly\r\n    const limits = TIER_LIMITS[effectiveTier as AllowedTiers]\r\n\r\n    // --- 1. Basic Data Validation ---\r\n    if (!sessionId || !files || !Array.isArray(files) || files.length === 0) {\r\n        return NextResponse.json({ error: \"Missing session ID or files.\" }, { status: 400 })\r\n    }\r\n\r\n    // CRITICAL: Filter out any potential undefined/null values from the files array\r\n    const validFiles = files.filter((f: any): f is string => typeof f === 'string' && f.trim() !== '')\r\n\r\n    if (validFiles.length === 0) {\r\n        return NextResponse.json({ error: \"No valid files selected for download.\" }, { status: 400 })\r\n    }\r\n\r\n    // --- 2. Tier and Limit Checks ---\r\n    if (downloadType === \"zip\" && limits && !limits.canDownloadZip) {\r\n      return NextResponse.json(\r\n        {\r\n          error: \"Your plan does not allow downloading multiple files as ZIP. Please upgrade.\",\r\n        },\r\n        { status: 403 },\r\n      )\r\n    }\r\n\r\n    // For free tier, check individual file limit\r\n    if (effectiveTier === \"free\" && validFiles.length > 10) {\r\n      return NextResponse.json(\r\n        {\r\n          error: `Free plan limited to 10 files per download. You selected ${validFiles.length}. Upgrade to download more.`,\r\n        },\r\n        { status: 403 },\r\n      )\r\n    }\r\n\r\n    // --- 3. Database Fetch and Update ---\r\n    const { db } = await connectToDatabase()\r\n    \r\n    // NOTE: sessionId is the unique ID for the session/zip contents\r\n    const sessionData = await db.collection(\"sessions\").findOne({ sessionId })\r\n\r\n    if (!sessionData || !sessionData.files) {\r\n      return NextResponse.json({ error: \"Session expired or files data missing.\" }, { status: 404 })\r\n    }\r\n\r\n    // Update download count for logged-in users\r\n    if (session?.user?.id) {\r\n        // Assuming session.user.id is the MongoDB _id (stringified)\r\n        try {\r\n          await db.collection(\"users\").updateOne({ _id: new ObjectId(session.user.id) }, { $inc: { totalDownloads: 1 } })\r\n        } catch (updateError) {\r\n          console.error(\"Failed to update download count:\", updateError);\r\n          // Continue execution even if update fails\r\n        }\r\n    }\r\n\r\n    // --- 4. File Preparation ---\r\n    let buffer: Buffer\r\n    let fileName: string\r\n    let contentType: string\r\n\r\n    if (downloadType === \"zip\" || validFiles.length > 1) {\r\n      // Create ZIP file\r\n      const zip = new JSZip()\r\n      for (const filePath of validFiles) {\r\n        const content = sessionData.files[filePath]\r\n        if (content) {\r\n          // The file is added to the ZIP with its full path as the name (e.g., folder/file.txt)\r\n          zip.file(filePath, content) \r\n        } else {\r\n            console.warn(`File path ${filePath} not found in session data.`)\r\n        }\r\n      }\r\n      \r\n      // Generate the ZIP blob and convert it to a Buffer\r\n      const blob = await zip.generateAsync({ type: \"nodebuffer\" })\r\n      buffer = blob\r\n      fileName = \"files.zip\"\r\n      contentType = \"application/zip\"\r\n\r\n    } else {\r\n      // Single file download (validFiles.length === 1)\r\n      const filePath = validFiles[0]\r\n      const content = sessionData.files[filePath]\r\n      \r\n      if (!content) {\r\n        return NextResponse.json({ error: `File not found in session: ${filePath}` }, { status: 404 })\r\n      }\r\n      \r\n      // Convert content (string or base64 data) to Buffer\r\n      buffer = Buffer.from(content)\r\n      fileName = filePath.split(\"/\").pop() || \"file\"\r\n      // Attempt to infer content type based on extension, otherwise default to octet-stream\r\n      const extension = fileName.split('.').pop()?.toLowerCase();\r\n      contentType = extension === 'json' ? 'application/json' : 'application/octet-stream';\r\n    }\r\n\r\n    // --- 5. Final Response ---\r\n    // FIX: Convert the Node.js Buffer to a standard ArrayBuffer slice, \r\n    // and explicitly cast to ArrayBuffer to satisfy NextResponse's type requirements.\r\n    const arrayBuffer = buffer.buffer.slice(\r\n      buffer.byteOffset,\r\n      buffer.byteOffset + buffer.length\r\n    ) as ArrayBuffer; \r\n\r\n    // Return the ArrayBuffer wrapped in a NextResponse\r\n    return new NextResponse(arrayBuffer, {\r\n      headers: {\r\n        \"Content-Disposition\": `attachment; filename=\"${fileName}\"`,\r\n        \"Content-Type\": contentType,\r\n        \"Content-Length\": buffer.length.toString(), \r\n      },\r\n    })\r\n  } catch (error) {\r\n    console.error(\"Download error:\", error)\r\n    return NextResponse.json({ error: \"Download failed due to server error\" }, { status: 500 })\r\n  }\r\n}"],"names":[],"mappings":"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"}}]
}