{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/mongodb.ts"],"sourcesContent":["import { MongoClient, type Db } from \"mongodb\"\r\n\r\nlet cachedClient: MongoClient | null = null\r\nlet cachedDb: Db | null = null\r\n\r\nexport async function connectToDatabase() {\r\n  const mongoUri = process.env.MONGODB_URI\r\n\r\n  if (!mongoUri || mongoUri.includes(\"your_mongodb_connection_string\")) {\r\n    console.warn(\"[MongoDB] MongoDB URI not configured. Using mock mode for development.\")\r\n    // Return a mock object for development when no valid URI is provided\r\n    return {\r\n      client: null,\r\n      db: {\r\n        collection: () => ({\r\n          findOne: async () => null,\r\n          insertOne: async () => ({ insertedId: \"mock-id\" }),\r\n          updateOne: async () => ({}),\r\n          deleteOne: async () => ({}),\r\n          find: () => ({ toArray: async () => [] }),\r\n        }),\r\n      } as any,\r\n    }\r\n  }\r\n\r\n  if (cachedClient && cachedDb) {\r\n    return { client: cachedClient, db: cachedDb }\r\n  }\r\n\r\n  try {\r\n    const client = new MongoClient(mongoUri)\r\n    await client.connect()\r\n    const db = client.db(\"code-explorer\")\r\n\r\n    cachedClient = client\r\n    cachedDb = db\r\n\r\n    return { client, db }\r\n  } catch (error) {\r\n    console.error(\"Failed to connect to MongoDB:\", error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function closeDatabase() {\r\n  if (cachedClient) {\r\n    await cachedClient.close()\r\n    cachedClient = null\r\n    cachedDb = null\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,eAAmC;AACvC,IAAI,WAAsB;AAEnB,eAAe;IACpB,MAAM,WAAW,QAAQ,GAAG,CAAC,WAAW;IAExC,IAAI,CAAC,YAAY,SAAS,QAAQ,CAAC,mCAAmC;QACpE,QAAQ,IAAI,CAAC;QACb,qEAAqE;QACrE,OAAO;YACL,QAAQ;YACR,IAAI;gBACF,YAAY,IAAM,CAAC;wBACjB,SAAS,UAAY;wBACrB,WAAW,UAAY,CAAC;gCAAE,YAAY;4BAAU,CAAC;wBACjD,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,MAAM,IAAM,CAAC;gCAAE,SAAS,UAAY,EAAE;4BAAC,CAAC;oBAC1C,CAAC;YACH;QACF;IACF;IAEA,IAAI,gBAAgB,UAAU;QAC5B,OAAO;YAAE,QAAQ;YAAc,IAAI;QAAS;IAC9C;IAEA,IAAI;QACF,MAAM,SAAS,IAAI,sHAAW,CAAC;QAC/B,MAAM,OAAO,OAAO;QACpB,MAAM,KAAK,OAAO,EAAE,CAAC;QAErB,eAAe;QACf,WAAW;QAEX,OAAO;YAAE;YAAQ;QAAG;IACtB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM;IACR;AACF;AAEO,eAAe;IACpB,IAAI,cAAc;QAChB,MAAM,aAAa,KAAK;QACxB,eAAe;QACf,WAAW;IACb;AACF"}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/app/api/share/access/route.ts"],"sourcesContent":["import { connectToDatabase } from \"@/lib/mongodb\"\r\nimport { NextResponse, type NextRequest } from \"next/server\"\r\n\r\n/**\r\n * Helper function to map a file entry (which might be a string or an object) \r\n * to the required metadata format ({ path, name }).\r\n * This handles legacy data where files were stored as just file path strings.\r\n */\r\nfunction mapFileToMetadata(fileEntry: any): { path: string, name: string } | null {\r\n    if (typeof fileEntry === 'string' && fileEntry.length > 0) {\r\n        // Handle legacy format: fileEntry is just the path string\r\n        const path = fileEntry;\r\n        // Extract file name from the path string\r\n        const parts = path.split('/');\r\n        const name = parts.pop() || '';\r\n\r\n        if (name) {\r\n            return { path, name };\r\n        }\r\n        return null; // Invalid string path\r\n    } else if (fileEntry && typeof fileEntry === 'object' && typeof fileEntry.path === 'string' && typeof fileEntry.name === 'string') {\r\n        // Handle new (correct) format: fileEntry is an object\r\n        if (fileEntry.path.length > 0 && fileEntry.name.length > 0) {\r\n            return {\r\n                path: fileEntry.path,\r\n                name: fileEntry.name,\r\n            };\r\n        }\r\n        return null; // Invalid object structure\r\n    }\r\n    \r\n    return null; // Not a valid file entry\r\n}\r\n\r\n// Define the type for file metadata explicitly\r\ntype FileMetadata = { path: string, name: string };\r\n\r\n/**\r\n * Dedicated route for accessing the metadata (name, path) of files \r\n * shared via a PIN, without downloading the content yet.\r\n */\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json()\r\n        const { pin } = body\r\n\r\n        if (!pin || typeof pin !== 'string') {\r\n            return NextResponse.json({ error: \"Missing or invalid share PIN.\" }, { status: 400 })\r\n        }\r\n\r\n        const { db } = await connectToDatabase()\r\n        \r\n        // 1. Find the sharing record using the PIN\r\n        // We project the 'files' array and 'expiresAt'.\r\n        const shareRecord = await db.collection(\"shared_pins\").findOne(\r\n            { pin }, \r\n            { projection: { files: 1, expiresAt: 1 } } \r\n        )\r\n        \r\n        if (!shareRecord) {\r\n            return NextResponse.json({ error: \"Invalid share PIN.\" }, { status: 404 })\r\n        }\r\n\r\n        // 2. Check expiration\r\n        if (shareRecord.expiresAt && new Date() > shareRecord.expiresAt) {\r\n            // Optional: delete expired record for cleanup\r\n            await db.collection(\"shared_pins\").deleteOne({ pin });\r\n            return NextResponse.json({ error: \"Share PIN has expired.\" }, { status: 410 })\r\n        }\r\n\r\n        // 3. Process the files array using the robust mapping function\r\n        const filesArray = Array.isArray(shareRecord.files) ? shareRecord.files : [];\r\n\r\n        // Map and filter out nulls (invalid file entries)\r\n        // By using FileMetadata | null as the type for 'f', we resolve the 'implicit any' warning.\r\n        const fileMetadata = filesArray\r\n            .map(mapFileToMetadata)\r\n            .filter((f: FileMetadata | null): f is FileMetadata => f !== null);\r\n\r\n        // 4. Return file metadata\r\n        return NextResponse.json({\r\n            success: true,\r\n            files: fileMetadata,\r\n        }, { status: 200 })\r\n\r\n    } catch (error) {\r\n        console.error(\"Error accessing shared files:\", error)\r\n        return NextResponse.json({ error: \"Server error during file access.\" }, { status: 500 })\r\n    }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA;;;;CAIC,GACD,SAAS,kBAAkB,SAAc;IACrC,IAAI,OAAO,cAAc,YAAY,UAAU,MAAM,GAAG,GAAG;QACvD,0DAA0D;QAC1D,MAAM,OAAO;QACb,yCAAyC;QACzC,MAAM,QAAQ,KAAK,KAAK,CAAC;QACzB,MAAM,OAAO,MAAM,GAAG,MAAM;QAE5B,IAAI,MAAM;YACN,OAAO;gBAAE;gBAAM;YAAK;QACxB;QACA,OAAO,MAAM,sBAAsB;IACvC,OAAO,IAAI,aAAa,OAAO,cAAc,YAAY,OAAO,UAAU,IAAI,KAAK,YAAY,OAAO,UAAU,IAAI,KAAK,UAAU;QAC/H,sDAAsD;QACtD,IAAI,UAAU,IAAI,CAAC,MAAM,GAAG,KAAK,UAAU,IAAI,CAAC,MAAM,GAAG,GAAG;YACxD,OAAO;gBACH,MAAM,UAAU,IAAI;gBACpB,MAAM,UAAU,IAAI;YACxB;QACJ;QACA,OAAO,MAAM,2BAA2B;IAC5C;IAEA,OAAO,MAAM,yBAAyB;AAC1C;AASO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,GAAG,EAAE,GAAG;QAEhB,IAAI,CAAC,OAAO,OAAO,QAAQ,UAAU;YACjC,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgC,GAAG;gBAAE,QAAQ;YAAI;QACvF;QAEA,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,IAAA,qIAAiB;QAEtC,2CAA2C;QAC3C,gDAAgD;QAChD,MAAM,cAAc,MAAM,GAAG,UAAU,CAAC,eAAe,OAAO,CAC1D;YAAE;QAAI,GACN;YAAE,YAAY;gBAAE,OAAO;gBAAG,WAAW;YAAE;QAAE;QAG7C,IAAI,CAAC,aAAa;YACd,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAqB,GAAG;gBAAE,QAAQ;YAAI;QAC5E;QAEA,sBAAsB;QACtB,IAAI,YAAY,SAAS,IAAI,IAAI,SAAS,YAAY,SAAS,EAAE;YAC7D,8CAA8C;YAC9C,MAAM,GAAG,UAAU,CAAC,eAAe,SAAS,CAAC;gBAAE;YAAI;YACnD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAyB,GAAG;gBAAE,QAAQ;YAAI;QAChF;QAEA,+DAA+D;QAC/D,MAAM,aAAa,MAAM,OAAO,CAAC,YAAY,KAAK,IAAI,YAAY,KAAK,GAAG,EAAE;QAE5E,kDAAkD;QAClD,2FAA2F;QAC3F,MAAM,eAAe,WAChB,GAAG,CAAC,mBACJ,MAAM,CAAC,CAAC,IAA8C,MAAM;QAEjE,0BAA0B;QAC1B,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB,SAAS;YACT,OAAO;QACX,GAAG;YAAE,QAAQ;QAAI;IAErB,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAmC,GAAG;YAAE,QAAQ;QAAI;IAC1F;AACJ"}}]
}