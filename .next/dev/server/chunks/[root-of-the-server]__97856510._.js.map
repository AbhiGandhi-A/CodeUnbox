{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/mongodb.ts"],"sourcesContent":["import { MongoClient, type Db } from \"mongodb\"\r\n\r\nlet cachedClient: MongoClient | null = null\r\nlet cachedDb: Db | null = null\r\n\r\nexport async function connectToDatabase() {\r\n  const mongoUri = process.env.MONGODB_URI\r\n\r\n  if (!mongoUri || mongoUri.includes(\"your_mongodb_connection_string\")) {\r\n    console.warn(\"[MongoDB] MongoDB URI not configured. Using mock mode for development.\")\r\n    // Return a mock object for development when no valid URI is provided\r\n    return {\r\n      client: null,\r\n      db: {\r\n        collection: () => ({\r\n          findOne: async () => null,\r\n          insertOne: async () => ({ insertedId: \"mock-id\" }),\r\n          updateOne: async () => ({}),\r\n          deleteOne: async () => ({}),\r\n          find: () => ({ toArray: async () => [] }),\r\n        }),\r\n      } as any,\r\n    }\r\n  }\r\n\r\n  if (cachedClient && cachedDb) {\r\n    return { client: cachedClient, db: cachedDb }\r\n  }\r\n\r\n  try {\r\n    const client = new MongoClient(mongoUri)\r\n    await client.connect()\r\n    const db = client.db(\"code-explorer\")\r\n\r\n    cachedClient = client\r\n    cachedDb = db\r\n\r\n    return { client, db }\r\n  } catch (error) {\r\n    console.error(\"Failed to connect to MongoDB:\", error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function closeDatabase() {\r\n  if (cachedClient) {\r\n    await cachedClient.close()\r\n    cachedClient = null\r\n    cachedDb = null\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,eAAmC;AACvC,IAAI,WAAsB;AAEnB,eAAe;IACpB,MAAM,WAAW,QAAQ,GAAG,CAAC,WAAW;IAExC,IAAI,CAAC,YAAY,SAAS,QAAQ,CAAC,mCAAmC;QACpE,QAAQ,IAAI,CAAC;QACb,qEAAqE;QACrE,OAAO;YACL,QAAQ;YACR,IAAI;gBACF,YAAY,IAAM,CAAC;wBACjB,SAAS,UAAY;wBACrB,WAAW,UAAY,CAAC;gCAAE,YAAY;4BAAU,CAAC;wBACjD,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,MAAM,IAAM,CAAC;gCAAE,SAAS,UAAY,EAAE;4BAAC,CAAC;oBAC1C,CAAC;YACH;QACF;IACF;IAEA,IAAI,gBAAgB,UAAU;QAC5B,OAAO;YAAE,QAAQ;YAAc,IAAI;QAAS;IAC9C;IAEA,IAAI;QACF,MAAM,SAAS,IAAI,sHAAW,CAAC;QAC/B,MAAM,OAAO,OAAO;QACpB,MAAM,KAAK,OAAO,EAAE,CAAC;QAErB,eAAe;QACf,WAAW;QAEX,OAAO;YAAE;YAAQ;QAAG;IACtB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM;IACR;AACF;AAEO,eAAe;IACpB,IAAI,cAAc;QAChB,MAAM,aAAa,KAAK;QACxB,eAAe;QACf,WAAW;IACb;AACF"}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/auth-config.ts"],"sourcesContent":["import { AuthOptions, User } from \"next-auth\"\r\nimport CredentialsProvider from \"next-auth/providers/credentials\"\r\nimport { connectToDatabase } from \"@/lib/mongodb\"Â \r\nimport bcrypt from \"bcryptjs\"\r\nimport { ObjectId } from \"mongodb\"Â \r\n\r\n// Note: Relying on the global 'User' type extended in next-auth.d.ts\r\n\r\n// Define the NextAuth options object\r\nexport const authOptions: AuthOptions = {\r\nÂ  // Use session strategy based on JWT (standard for stateless serverless functions)\r\nÂ  session: {\r\nÂ  Â  strategy: \"jwt\",\r\nÂ  },\r\nÂ Â \r\nÂ  providers: [\r\nÂ  Â  CredentialsProvider({\r\nÂ  Â  Â  name: \"Credentials\",\r\nÂ  Â  Â  credentials: {\r\nÂ  Â  Â  Â  email: { label: \"Email\", type: \"email\" },\r\nÂ  Â  Â  Â  password: { label: \"Password\", type: \"password\" },\r\nÂ  Â  Â  },\r\nÂ  Â  Â  // Explicitly define the return type as User | null (using the globally extended type)\r\nÂ  Â  Â  async authorize(credentials): Promise<User | null> {\r\nÂ  Â  Â  Â  if (!credentials) {\r\nÂ  Â  Â  Â  Â  return null\r\nÂ  Â  Â  Â  }\r\nÂ  Â  Â  Â  const { email, password } = credentials\r\n\r\nÂ  Â  Â  Â  try {\r\nÂ  Â  Â  Â  Â  const { db } = await connectToDatabase()\r\nÂ  Â  Â  Â  Â  const user = await db.collection(\"users\").findOne({ email })\r\n\r\nÂ  Â  Â  Â  Â  if (!user) {\r\nÂ  Â  Â  Â  Â  Â  console.error(\"Login failed: User not found for email:\", email)\r\nÂ  Â  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")Â \r\nÂ  Â  Â  Â  Â  }\r\n\r\nÂ  Â  Â  Â  Â  const isValid = await bcrypt.compare(password, user.password)\r\nÂ  Â  Â  Â  Â Â \r\nÂ  Â  Â  Â  Â  if (!isValid) {\r\nÂ  Â  Â  Â  Â  Â  console.error(\"Login failed: Invalid password for email:\", email)\r\nÂ  Â  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")\r\nÂ  Â  Â  Â  Â  }\r\nÂ  Â  Â  Â  Â Â \r\nÂ  Â  Â  Â  Â  // Return an object that matches the ExtendedUser interface structure.\r\nÂ  Â  Â  Â  Â  return {\r\nÂ  Â  Â  Â  Â  Â  id: user._id.toString(), // Must be a string\r\nÂ  Â  Â  Â  Â  Â  name: user.name as string, // Cast to string if needed\r\nÂ  Â  Â  Â  Â  Â  email: user.email as string, // Cast to string if needed\r\nÂ  Â  Â  Â  Â  Â  // ðŸ’¡ FIX 4: Use 'subscriptionPlan' instead of 'tier'\r\nÂ  Â  Â  Â  Â  Â  subscriptionPlan: user.subscriptionPlan || \"free\",Â \r\nÂ  Â  Â  Â  Â  } as User\r\nÂ  Â  Â  Â  } catch (e) {\r\nÂ  Â  Â  Â  Â  console.error(\"Error during authorization:\", e)\r\nÂ  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")Â \r\nÂ  Â  Â  Â  }\r\nÂ  Â  Â  },\r\nÂ  Â  }),\r\nÂ  ],\r\nÂ Â \r\nÂ  // Custom pages configuration to handle redirects\r\nÂ  pages: {\r\nÂ  Â  signIn: \"/login\",\r\nÂ  Â  error: \"/login\",Â \r\nÂ  },\r\n\r\nÂ  callbacks: {\r\nÂ  Â  // Add custom properties (id, subscriptionPlan) to the JWT\r\nÂ  Â  async jwt({ token, user, trigger, session }) {\r\nÂ  Â  Â  if (user) {\r\nÂ  Â  Â  Â  token.id = user.id\r\nÂ  Â  Â  Â  // ðŸ’¡ FIX 5: Use 'subscriptionPlan' instead of 'tier'\r\nÂ  Â  Â  Â  token.subscriptionPlan = (user as User).subscriptionPlan\r\nÂ  Â  Â  }\r\n\r\n      // ðŸ’¡ FIX 6: Handle session refresh triggered by update() call from client\r\n      if (trigger === \"update\" && session && (session as { subscriptionPlan?: string }).subscriptionPlan) {\r\n        // Update the token's subscriptionPlan with the new value from the update() payload\r\n        token.subscriptionPlan = (session as { subscriptionPlan: string }).subscriptionPlan\r\n      }\r\nÂ  Â  Â  return token\r\nÂ  Â  },\r\nÂ  Â  // Add custom properties (id, subscriptionPlan) to the session object exposed on the client\r\nÂ  Â  async session({ session, token }) {\r\nÂ  Â  Â  if (session.user) {\r\nÂ  Â  Â  Â  // @ts-ignore: Add custom properties to session.user\r\nÂ  Â  Â  Â  session.user.id = token.id\r\nÂ  Â  Â  Â  // ðŸ’¡ FIX 7: Use 'subscriptionPlan' instead of 'tier'\r\nÂ  Â  Â  Â  // @ts-ignore: Access token.subscriptionPlan\r\nÂ  Â  Â  Â  session.user.subscriptionPlan = token.subscriptionPlan\r\nÂ  Â  Â  }\r\nÂ  Â  Â  return session\r\nÂ  Â  },\r\nÂ  },\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAMO,MAAM,cAA2B;IACtC,kFAAkF;IAClF,SAAS;QACP,UAAU;IACZ;IAEA,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,sFAAsF;YACtF,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa;oBAChB,OAAO;gBACT;gBACA,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG;gBAE5B,IAAI;oBACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,IAAA,qIAAiB;oBACtC,MAAM,OAAO,MAAM,GAAG,UAAU,CAAC,SAAS,OAAO,CAAC;wBAAE;oBAAM;oBAE1D,IAAI,CAAC,MAAM;wBACT,QAAQ,KAAK,CAAC,2CAA2C;wBACzD,MAAM,IAAI,MAAM;oBAClB;oBAEA,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;oBAE5D,IAAI,CAAC,SAAS;wBACZ,QAAQ,KAAK,CAAC,6CAA6C;wBAC3D,MAAM,IAAI,MAAM;oBAClB;oBAEA,sEAAsE;oBACtE,OAAO;wBACL,IAAI,KAAK,GAAG,CAAC,QAAQ;wBACrB,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;wBACjB,qDAAqD;wBACrD,kBAAkB,KAAK,gBAAgB,IAAI;oBAC7C;gBACF,EAAE,OAAO,GAAG;oBACV,QAAQ,KAAK,CAAC,+BAA+B;oBAC7C,MAAM,IAAI,MAAM;gBAClB;YACF;QACF;KACD;IAED,iDAAiD;IACjD,OAAO;QACL,QAAQ;QACR,OAAO;IACT;IAEA,WAAW;QACT,0DAA0D;QAC1D,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACzC,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,qDAAqD;gBACrD,MAAM,gBAAgB,GAAG,AAAC,KAAc,gBAAgB;YAC1D;YAEA,0EAA0E;YAC1E,IAAI,YAAY,YAAY,WAAW,AAAC,QAA0C,gBAAgB,EAAE;gBAClG,mFAAmF;gBACnF,MAAM,gBAAgB,GAAG,AAAC,QAAyC,gBAAgB;YACrF;YACA,OAAO;QACT;QACA,2FAA2F;QAC3F,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,oDAAoD;gBACpD,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,qDAAqD;gBACrD,4CAA4C;gBAC5C,QAAQ,IAAI,CAAC,gBAAgB,GAAG,MAAM,gBAAgB;YACxD;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 276, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/app/api/payment/verify/route.ts"],"sourcesContent":["import { connectToDatabase } from \"@/lib/mongodb\"\r\nimport { NextRequest, NextResponse } from \"next/server\"\r\nimport { getServerSession } from \"next-auth/next\"\r\nimport { authOptions } from \"@/lib/auth-config\"\r\nimport crypto from \"crypto\"\r\nimport { ObjectId } from \"mongodb\"\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const RAZORPAY_KEY_SECRET = process.env.RAZORPAY_KEY_SECRET\r\n\r\n    if (!RAZORPAY_KEY_SECRET) {\r\n      return NextResponse.json(\r\n        { error: \"Payment server misconfigured\" },\r\n        { status: 500 }\r\n      )\r\n    }\r\n\r\n    const session = await getServerSession(authOptions)\r\n    if (!session?.user?.id) {\r\n      return NextResponse.json({ error: \"Authentication required\" }, { status: 401 })\r\n    }\r\n\r\n    const { orderId, paymentId, signature } = await request.json()\r\n\r\n    // Signature verification\r\n    const expected = crypto\r\n      .createHmac(\"sha256\", RAZORPAY_KEY_SECRET)\r\n      .update(`${orderId}|${paymentId}`)\r\n      .digest(\"hex\")\r\n\r\n    if (expected !== signature) {\r\n      return NextResponse.json(\r\n        { error: \"Payment verification failed\" },\r\n        { status: 400 }\r\n      )\r\n    }\r\n\r\n    const { db } = await connectToDatabase()\r\n\r\n    // Fetch order details\r\n    const order = await db.collection(\"orders\").findOne({ orderId })\r\n    if (!order) {\r\n      return NextResponse.json({ error: \"Order not found\" }, { status: 404 })\r\n    }\r\n\r\n    // Update order status\r\n    await db.collection(\"orders\").updateOne(\r\n      { orderId },\r\n      {\r\n        $set: {\r\n          status: \"verified\",\r\n          paymentId,\r\n          verifiedAt: new Date(),\r\n        },\r\n      }\r\n    )\r\n\r\n    // Calculate subscription expiry\r\n    const expiry = new Date()\r\n    if (order.plan === \"monthly\") expiry.setMonth(expiry.getMonth() + 1)\r\n    else expiry.setFullYear(expiry.getFullYear() + 1)\r\n\r\n    // Update user's subscription in the database\r\n    await db.collection(\"users\").updateOne(\r\n      { _id: new ObjectId(session.user.id) },\r\n      {\r\n        $set: {\r\n          subscriptionPlan: order.plan,\r\n          subscriptionExpiry: expiry,\r\n          updatedAt: new Date(),\r\n        },\r\n      }\r\n    )\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      message: \"Payment verified\",\r\n      plan: order.plan,\r\n    })\r\n  } catch (error) {\r\n    console.error(\"Verification error:\", error)\r\n    return NextResponse.json({ error: \"Verification failed\" }, { status: 500 })\r\n  }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,sBAAsB,QAAQ,GAAG,CAAC,mBAAmB;QAE3D,IAAI,CAAC,qBAAqB;YACxB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA+B,GACxC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,UAAU,MAAM,IAAA,mKAAgB,EAAC,sIAAW;QAClD,IAAI,CAAC,SAAS,MAAM,IAAI;YACtB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QAC/E;QAEA,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,MAAM,QAAQ,IAAI;QAE5D,yBAAyB;QACzB,MAAM,WAAW,gHAAM,CACpB,UAAU,CAAC,UAAU,qBACrB,MAAM,CAAC,GAAG,QAAQ,CAAC,EAAE,WAAW,EAChC,MAAM,CAAC;QAEV,IAAI,aAAa,WAAW;YAC1B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,IAAA,qIAAiB;QAEtC,sBAAsB;QACtB,MAAM,QAAQ,MAAM,GAAG,UAAU,CAAC,UAAU,OAAO,CAAC;YAAE;QAAQ;QAC9D,IAAI,CAAC,OAAO;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAkB,GAAG;gBAAE,QAAQ;YAAI;QACvE;QAEA,sBAAsB;QACtB,MAAM,GAAG,UAAU,CAAC,UAAU,SAAS,CACrC;YAAE;QAAQ,GACV;YACE,MAAM;gBACJ,QAAQ;gBACR;gBACA,YAAY,IAAI;YAClB;QACF;QAGF,gCAAgC;QAChC,MAAM,SAAS,IAAI;QACnB,IAAI,MAAM,IAAI,KAAK,WAAW,OAAO,QAAQ,CAAC,OAAO,QAAQ,KAAK;aAC7D,OAAO,WAAW,CAAC,OAAO,WAAW,KAAK;QAE/C,6CAA6C;QAC7C,MAAM,GAAG,UAAU,CAAC,SAAS,SAAS,CACpC;YAAE,KAAK,IAAI,mHAAQ,CAAC,QAAQ,IAAI,CAAC,EAAE;QAAE,GACrC;YACE,MAAM;gBACJ,kBAAkB,MAAM,IAAI;gBAC5B,oBAAoB;gBACpB,WAAW,IAAI;YACjB;QACF;QAGF,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS;YACT,MAAM,MAAM,IAAI;QAClB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAsB,GAAG;YAAE,QAAQ;QAAI;IAC3E;AACF"}}]
}