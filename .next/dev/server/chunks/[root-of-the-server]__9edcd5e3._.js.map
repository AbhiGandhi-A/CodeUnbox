{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/mongodb.ts"],"sourcesContent":["import { MongoClient, type Db } from \"mongodb\"\r\n\r\nlet cachedClient: MongoClient | null = null\r\nlet cachedDb: Db | null = null\r\n\r\nexport async function connectToDatabase() {\r\n  const mongoUri = process.env.MONGODB_URI\r\n\r\n  if (!mongoUri || mongoUri.includes(\"your_mongodb_connection_string\")) {\r\n    console.warn(\"[MongoDB] MongoDB URI not configured. Using mock mode for development.\")\r\n    // Return a mock object for development when no valid URI is provided\r\n    return {\r\n      client: null,\r\n      db: {\r\n        collection: () => ({\r\n          findOne: async () => null,\r\n          insertOne: async () => ({ insertedId: \"mock-id\" }),\r\n          updateOne: async () => ({}),\r\n          deleteOne: async () => ({}),\r\n          find: () => ({ toArray: async () => [] }),\r\n        }),\r\n      } as any,\r\n    }\r\n  }\r\n\r\n  if (cachedClient && cachedDb) {\r\n    return { client: cachedClient, db: cachedDb }\r\n  }\r\n\r\n  try {\r\n    const client = new MongoClient(mongoUri)\r\n    await client.connect()\r\n    const db = client.db(\"code-explorer\")\r\n\r\n    cachedClient = client\r\n    cachedDb = db\r\n\r\n    return { client, db }\r\n  } catch (error) {\r\n    console.error(\"Failed to connect to MongoDB:\", error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function closeDatabase() {\r\n  if (cachedClient) {\r\n    await cachedClient.close()\r\n    cachedClient = null\r\n    cachedDb = null\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,eAAmC;AACvC,IAAI,WAAsB;AAEnB,eAAe;IACpB,MAAM,WAAW,QAAQ,GAAG,CAAC,WAAW;IAExC,IAAI,CAAC,YAAY,SAAS,QAAQ,CAAC,mCAAmC;QACpE,QAAQ,IAAI,CAAC;QACb,qEAAqE;QACrE,OAAO;YACL,QAAQ;YACR,IAAI;gBACF,YAAY,IAAM,CAAC;wBACjB,SAAS,UAAY;wBACrB,WAAW,UAAY,CAAC;gCAAE,YAAY;4BAAU,CAAC;wBACjD,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,MAAM,IAAM,CAAC;gCAAE,SAAS,UAAY,EAAE;4BAAC,CAAC;oBAC1C,CAAC;YACH;QACF;IACF;IAEA,IAAI,gBAAgB,UAAU;QAC5B,OAAO;YAAE,QAAQ;YAAc,IAAI;QAAS;IAC9C;IAEA,IAAI;QACF,MAAM,SAAS,IAAI,sHAAW,CAAC;QAC/B,MAAM,OAAO,OAAO;QACpB,MAAM,KAAK,OAAO,EAAE,CAAC;QAErB,eAAe;QACf,WAAW;QAEX,OAAO;YAAE;YAAQ;QAAG;IACtB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM;IACR;AACF;AAEO,eAAe;IACpB,IAAI,cAAc;QAChB,MAAM,aAAa,KAAK;QACxB,eAAe;QACf,WAAW;IACb;AACF"}},
    {"offset": {"line": 176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/auth-config.ts"],"sourcesContent":["import { AuthOptions, User } from \"next-auth\"\r\nimport CredentialsProvider from \"next-auth/providers/credentials\"\r\nimport { connectToDatabase } from \"@/lib/mongodb\"Â \r\nimport bcrypt from \"bcryptjs\"\r\nimport { ObjectId } from \"mongodb\"Â \r\n\r\nexport const authOptions: AuthOptions = {\r\nÂ  session: {\r\nÂ  Â  strategy: \"jwt\",\r\nÂ  },\r\nÂ Â \r\nÂ  providers: [\r\nÂ  Â  CredentialsProvider({\r\nÂ  Â  Â  name: \"Credentials\",\r\nÂ  Â  Â  credentials: {\r\nÂ  Â  Â  Â  email: { label: \"Email\", type: \"email\" },\r\nÂ  Â  Â  Â  password: { label: \"Password\", type: \"password\" },\r\nÂ  Â  Â  },\r\nÂ  Â  Â  async authorize(credentials): Promise<User | null> {\r\nÂ  Â  Â  Â  if (!credentials) {\r\nÂ  Â  Â  Â  Â  return null\r\nÂ  Â  Â  Â  }\r\n        // ðŸŒŸ FIX: Normalize incoming login email to lowercase\r\n        const email = String(credentials.email).toLowerCase()\r\nÂ  Â  Â  Â  const { password } = credentials\r\n\r\nÂ  Â  Â  Â  try {\r\nÂ  Â  Â  Â  Â  const { db } = await connectToDatabase()\r\nÂ  Â  Â  Â  Â  // Search using the normalized lowercase email\r\nÂ  Â  Â  Â  Â  const user = await db.collection(\"users\").findOne({ email })\r\n\r\nÂ  Â  Â  Â  Â  if (!user) {\r\nÂ  Â  Â  Â  Â  Â  console.error(\"LOGIN FAIL: User not found for email:\", email)\r\nÂ  Â  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")Â \r\nÂ  Â  Â  Â  Â  }\r\n\r\nÂ  Â  Â  Â  Â  const isValid = await bcrypt.compare(password, user.password)\r\nÂ  Â  Â  Â  Â Â \r\nÂ  Â  Â  Â  Â  if (!isValid) {\r\nÂ  Â  Â  Â  Â  Â  console.error(\"LOGIN FAIL: Invalid password for email:\", email)\r\nÂ  Â  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")\r\nÂ  Â  Â  Â  Â  }\r\nÂ  Â  Â  Â  Â Â \r\nÂ  Â  Â  Â  Â  return {\r\nÂ  Â  Â  Â  Â  Â  id: user._id.toString(),\r\nÂ  Â  Â  Â  Â  Â  name: user.name as string,\r\nÂ  Â  Â  Â  Â  Â  email: user.email as string, \r\nÂ  Â  Â  Â  Â  Â  subscriptionPlan: user.subscriptionPlan || \"free\",Â \r\nÂ  Â  Â  Â  Â  } as User\r\nÂ  Â  Â  Â  } catch (e) {\r\nÂ  Â  Â  Â  Â  console.error(\"Error during authorization:\", e)\r\nÂ  Â  Â  Â  Â  throw new Error(\"Invalid credentials\")Â \r\nÂ  Â  Â  Â  }\r\nÂ  Â  Â  },\r\nÂ  Â  }),\r\nÂ  ],\r\nÂ Â \r\nÂ  pages: {\r\nÂ  Â  signIn: \"/register\",\r\nÂ  Â  error: \"/register\", // Changed from /login to /register for consistency with flow\r\nÂ  },\r\n\r\nÂ  callbacks: {\r\nÂ  Â  async jwt({ token, user, trigger, session }) {\r\nÂ  Â  Â  if (user) {\r\nÂ  Â  Â  Â  token.id = user.id\r\nÂ  Â  Â  Â  token.subscriptionPlan = (user as User).subscriptionPlan\r\nÂ  Â  Â  }\r\nÂ  Â  Â  if (trigger === \"update\" && session && (session as { subscriptionPlan?: string }).subscriptionPlan) {\r\nÂ  Â  Â  Â  token.subscriptionPlan = (session as { subscriptionPlan: string }).subscriptionPlan\r\nÂ  Â  Â  }\r\nÂ  Â  Â  return token\r\nÂ  Â  },\r\nÂ  Â  async session({ session, token }) {\r\nÂ  Â  Â  if (session.user) {\r\nÂ  Â  Â  Â  // @ts-ignore\r\nÂ  Â  Â  Â  session.user.id = token.id\r\nÂ  Â  Â  Â  // @ts-ignore\r\nÂ  Â  Â  Â  session.user.subscriptionPlan = token.subscriptionPlan\r\nÂ  Â  Â  }\r\nÂ  Â  Â  return session\r\nÂ  Â  },\r\nÂ  },\r\n}"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAGO,MAAM,cAA2B;IACtC,SAAS;QACP,UAAU;IACZ;IAEA,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa;oBAChB,OAAO;gBACT;gBACA,sDAAsD;gBACtD,MAAM,QAAQ,OAAO,YAAY,KAAK,EAAE,WAAW;gBACnD,MAAM,EAAE,QAAQ,EAAE,GAAG;gBAErB,IAAI;oBACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,IAAA,qIAAiB;oBACtC,8CAA8C;oBAC9C,MAAM,OAAO,MAAM,GAAG,UAAU,CAAC,SAAS,OAAO,CAAC;wBAAE;oBAAM;oBAE1D,IAAI,CAAC,MAAM;wBACT,QAAQ,KAAK,CAAC,yCAAyC;wBACvD,MAAM,IAAI,MAAM;oBAClB;oBAEA,MAAM,UAAU,MAAM,8IAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;oBAE5D,IAAI,CAAC,SAAS;wBACZ,QAAQ,KAAK,CAAC,2CAA2C;wBACzD,MAAM,IAAI,MAAM;oBAClB;oBAEA,OAAO;wBACL,IAAI,KAAK,GAAG,CAAC,QAAQ;wBACrB,MAAM,KAAK,IAAI;wBACf,OAAO,KAAK,KAAK;wBACjB,kBAAkB,KAAK,gBAAgB,IAAI;oBAC7C;gBACF,EAAE,OAAO,GAAG;oBACV,QAAQ,KAAK,CAAC,+BAA+B;oBAC7C,MAAM,IAAI,MAAM;gBAClB;YACF;QACF;KACD;IAED,OAAO;QACL,QAAQ;QACR,OAAO;IACT;IAEA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE;YACzC,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,gBAAgB,GAAG,AAAC,KAAc,gBAAgB;YAC1D;YACA,IAAI,YAAY,YAAY,WAAW,AAAC,QAA0C,gBAAgB,EAAE;gBAClG,MAAM,gBAAgB,GAAG,AAAC,QAAyC,gBAAgB;YACrF;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,aAAa;gBACb,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,aAAa;gBACb,QAAQ,IAAI,CAAC,gBAAgB,GAAG,MAAM,gBAAgB;YACxD;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 274, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/tier-limits.ts"],"sourcesContent":["export const TIER_LIMITS = {\r\n  anonymous: {\r\n    maxFilesPerZip: 100,\r\n    canDownloadIndividual: false,\r\n    canDownloadZip: false,\r\n    canSave: false,\r\n    maxSavedZips: 0,\r\n    maxDownloadsPerSession: 0,\r\n  },\r\n  free: {\r\n    maxFilesPerZip: 200,\r\n    canDownloadIndividual: true,\r\n    canDownloadZip: true,\r\n    canSave: false,\r\n    maxSavedZips: 0,\r\n    maxDownloadsPerSession: 10,\r\n  },\r\n  monthly: {\r\n    maxFilesPerZip: Number.POSITIVE_INFINITY,\r\n    canDownloadIndividual: true,\r\n    canDownloadZip: true,\r\n    canSave: true,\r\n    maxSavedZips: 5,\r\n    maxDownloadsPerSession: Number.POSITIVE_INFINITY,\r\n  },\r\n  yearly: {\r\n    maxFilesPerZip: Number.POSITIVE_INFINITY,\r\n    canDownloadIndividual: true,\r\n    canDownloadZip: true,\r\n    canSave: true,\r\n    maxSavedZips: 15,\r\n    maxDownloadsPerSession: Number.POSITIVE_INFINITY,\r\n  },\r\n} as const\r\n"],"names":[],"mappings":";;;;AAAO,MAAM,cAAc;IACzB,WAAW;QACT,gBAAgB;QAChB,uBAAuB;QACvB,gBAAgB;QAChB,SAAS;QACT,cAAc;QACd,wBAAwB;IAC1B;IACA,MAAM;QACJ,gBAAgB;QAChB,uBAAuB;QACvB,gBAAgB;QAChB,SAAS;QACT,cAAc;QACd,wBAAwB;IAC1B;IACA,SAAS;QACP,gBAAgB,OAAO,iBAAiB;QACxC,uBAAuB;QACvB,gBAAgB;QAChB,SAAS;QACT,cAAc;QACd,wBAAwB,OAAO,iBAAiB;IAClD;IACA,QAAQ;QACN,gBAAgB,OAAO,iBAAiB;QACxC,uBAAuB;QACvB,gBAAgB;QAChB,SAAS;QACT,cAAc;QACd,wBAAwB,OAAO,iBAAiB;IAClD;AACF"}},
    {"offset": {"line": 316, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/app/api/zip/extract/route.ts"],"sourcesContent":["import { connectToDatabase } from \"@/lib/mongodb\"\r\nimport { type NextRequest, NextResponse } from \"next/server\"\r\nimport { getServerSession } from \"next-auth/next\"\r\nimport { authOptions } from \"@/lib/auth-config\"\r\nimport JSZip from \"jszip\"\r\nimport { TIER_LIMITS } from \"@/lib/tier-limits\"\r\n\r\n// NOTE: The 'config' export with 'api' properties is deprecated and ignored in the App Router.\r\n// We remove this block to resolve the runtime warning/error, allowing Next.js to handle the\r\n// streaming of the file upload via request.formData() correctly.\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const session = await getServerSession(authOptions)\r\n    // Note: Assuming 'free' tier for session-less users, should be 'anonymous' if no session.\r\n    const userTier = session?.user?.subscriptionPlan || \"anonymous\" \r\n    const limits = TIER_LIMITS[userTier as keyof typeof TIER_LIMITS]\r\n\r\n    const formData = await request.formData()\r\n    const file = formData.get(\"file\") as File\r\n\r\n    if (!file || !file.name.endsWith(\".zip\")) {\r\n      return NextResponse.json({ error: \"Only .zip files are supported\" }, { status: 400 })\r\n    }\r\n    \r\n    // Check file size limit (application logic check)\r\n    // We rely on request.formData() streaming but keep this check for user feedback.\r\n    if (file.size > 25 * 1024 * 1024) { // 25MB limit check inside the application logic\r\n      return NextResponse.json({ error: \"File size exceeds 25MB limit.\" }, { status: 413 })\r\n    }\r\n\r\n\r\n    const buffer = await file.arrayBuffer()\r\n    const zip = new JSZip()\r\n    await zip.loadAsync(buffer)\r\n\r\n    const fileEntries: Array<{ path: string; isDirectory: boolean }> = []\r\n    let fileCount = 0\r\n\r\n    zip.forEach((relativePath, zipEntry) => {\r\n      // Exclude hidden files and directories (starting with '.')\r\n      if (!relativePath.startsWith(\".\") && !relativePath.includes(\"/.\")) {\r\n        fileEntries.push({\r\n          path: relativePath,\r\n          isDirectory: zipEntry.dir,\r\n        })\r\n        if (!zipEntry.dir) fileCount++\r\n      }\r\n    })\r\n\r\n    // Check file count limit\r\n    if (fileCount > limits.maxFilesPerZip) {\r\n      return NextResponse.json(\r\n        {\r\n          error: `Exceeded file limit. Your plan allows ${limits.maxFilesPerZip} files. Please upgrade your plan.`,\r\n        },\r\n        { status: 403 },\r\n      )\r\n    }\r\n\r\n    // Store session data\r\n    // Use a robust way to generate a unique session ID\r\n    const sessionId = `zip-session-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`\r\n    const { db } = await connectToDatabase()\r\n\r\n    const sessionData = {\r\n      sessionId,\r\n      userId: session?.user?.id || null,\r\n      files: new Map<string, string>(),\r\n      fileEntries,\r\n      fileCount,\r\n      expiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24), // 24 hours\r\n    }\r\n\r\n    // Read file contents\r\n    for (const entry of fileEntries) {\r\n      if (!entry.isDirectory) {\r\n        try {\r\n          const zipEntry = zip.file(entry.path)\r\n          if (zipEntry) {\r\n            // Using 'text' if possible for better encoding compatibility\r\n            const content = await zipEntry.async(\"text\")\r\n            sessionData.files.set(entry.path, content)\r\n          }\r\n        } catch (err) {\r\n          console.error(`Failed to read ${entry.path}:`, err)\r\n          // Handle files that cannot be read as text (e.g., binaries) by skipping them or giving an empty string.\r\n          sessionData.files.set(entry.path, \"\")\r\n        }\r\n      }\r\n    }\r\n\r\n    // Store in database\r\n    await db.collection(\"sessions\").insertOne({\r\n      sessionId,\r\n      files: Object.fromEntries(sessionData.files),\r\n      fileEntries,\r\n      fileCount,\r\n      userId: session?.user?.id || null,\r\n      expiresAt: sessionData.expiresAt,\r\n      createdAt: new Date(),\r\n    })\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      sessionId,\r\n      fileCount,\r\n      files: Object.fromEntries(sessionData.files),\r\n    })\r\n  } catch (error) {\r\n    console.error(\"ZIP extraction error:\", error)\r\n    return NextResponse.json({ error: \"Failed to extract ZIP file\" }, { status: 500 })\r\n  }\r\n}"],"names":[],"mappings":"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"}}]
}