{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/lib/mongodb.ts"],"sourcesContent":["import { MongoClient, type Db } from \"mongodb\"\r\n\r\nlet cachedClient: MongoClient | null = null\r\nlet cachedDb: Db | null = null\r\n\r\nexport async function connectToDatabase() {\r\n  const mongoUri = process.env.MONGODB_URI\r\n\r\n  if (!mongoUri || mongoUri.includes(\"your_mongodb_connection_string\")) {\r\n    console.warn(\"[MongoDB] MongoDB URI not configured. Using mock mode for development.\")\r\n    // Return a mock object for development when no valid URI is provided\r\n    return {\r\n      client: null,\r\n      db: {\r\n        collection: () => ({\r\n          findOne: async () => null,\r\n          insertOne: async () => ({ insertedId: \"mock-id\" }),\r\n          updateOne: async () => ({}),\r\n          deleteOne: async () => ({}),\r\n          find: () => ({ toArray: async () => [] }),\r\n        }),\r\n      } as any,\r\n    }\r\n  }\r\n\r\n  if (cachedClient && cachedDb) {\r\n    return { client: cachedClient, db: cachedDb }\r\n  }\r\n\r\n  try {\r\n    const client = new MongoClient(mongoUri)\r\n    await client.connect()\r\n    const db = client.db(\"code-explorer\")\r\n\r\n    cachedClient = client\r\n    cachedDb = db\r\n\r\n    return { client, db }\r\n  } catch (error) {\r\n    console.error(\"Failed to connect to MongoDB:\", error)\r\n    throw error\r\n  }\r\n}\r\n\r\nexport async function closeDatabase() {\r\n  if (cachedClient) {\r\n    await cachedClient.close()\r\n    cachedClient = null\r\n    cachedDb = null\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA,IAAI,eAAmC;AACvC,IAAI,WAAsB;AAEnB,eAAe;IACpB,MAAM,WAAW,QAAQ,GAAG,CAAC,WAAW;IAExC,IAAI,CAAC,YAAY,SAAS,QAAQ,CAAC,mCAAmC;QACpE,QAAQ,IAAI,CAAC;QACb,qEAAqE;QACrE,OAAO;YACL,QAAQ;YACR,IAAI;gBACF,YAAY,IAAM,CAAC;wBACjB,SAAS,UAAY;wBACrB,WAAW,UAAY,CAAC;gCAAE,YAAY;4BAAU,CAAC;wBACjD,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,WAAW,UAAY,CAAC,CAAC,CAAC;wBAC1B,MAAM,IAAM,CAAC;gCAAE,SAAS,UAAY,EAAE;4BAAC,CAAC;oBAC1C,CAAC;YACH;QACF;IACF;IAEA,IAAI,gBAAgB,UAAU;QAC5B,OAAO;YAAE,QAAQ;YAAc,IAAI;QAAS;IAC9C;IAEA,IAAI;QACF,MAAM,SAAS,IAAI,sHAAW,CAAC;QAC/B,MAAM,OAAO,OAAO;QACpB,MAAM,KAAK,OAAO,EAAE,CAAC;QAErB,eAAe;QACf,WAAW;QAEX,OAAO;YAAE;YAAQ;QAAG;IACtB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM;IACR;AACF;AAEO,eAAe;IACpB,IAAI,cAAc;QAChB,MAAM,aAAa,KAAK;QACxB,eAAe;QACf,WAAW;IACb;AACF"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/abhig/Downloads/zip-explorer1/app/api/share/download/route.ts"],"sourcesContent":["import { connectToDatabase } from \"@/lib/mongodb\"\r\nimport { NextResponse, type NextRequest } from \"next/server\"\r\nimport JSZip from \"jszip\"\r\n\r\n/**\r\n * Dedicated route for downloading files accessed via a shared PIN.\r\n * It uses the PIN to find the session/shared data and zips the requested file paths.\r\n * The file contents are assumed to be stored directly in the `shared_pins` collection.\r\n */\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json()\r\n        const { pin, files } = body\r\n        \r\n        if (!pin || !files || !Array.isArray(files) || files.length === 0) {\r\n            return NextResponse.json({ error: \"Missing PIN or files to download.\" }, { status: 400 })\r\n        }\r\n\r\n        const { db } = await connectToDatabase()\r\n        \r\n        // 1. Find the sharing record using the PIN in the shared_pins collection\r\n        const shareRecord = await db.collection(\"shared_pins\").findOne({ pin })\r\n        \r\n        if (!shareRecord) {\r\n            return NextResponse.json({ error: \"Invalid or expired share PIN.\" }, { status: 404 })\r\n        }\r\n\r\n        // Check expiration\r\n        if (shareRecord.expiresAt && new Date() > shareRecord.expiresAt) {\r\n            // Optional: delete expired record\r\n            await db.collection(\"shared_pins\").deleteOne({ pin });\r\n            return NextResponse.json({ error: \"Share PIN has expired.\" }, { status: 410 })\r\n        }\r\n\r\n        // 2. The file contents are assumed to be stored directly in `shareRecord.files`\r\n        // Defensive mapping to ensure we only proceed with valid data and handle `shareRecord.files` possibly being null/undefined.\r\n        const filesArray = Array.isArray(shareRecord.files) ? shareRecord.files : [];\r\n        \r\n        // Explicitly define the map type and ensure content is cast to string to satisfy JSZip's overloads\r\n        const fileContentsMap: Map<string, string> = new Map(\r\n            filesArray\r\n                .filter((f: any) => f && typeof f.path === 'string' && typeof f.content === 'string')\r\n                .map((f: any) => [f.path, f.content as string])\r\n        );\r\n\r\n        // Filter for only valid string paths\r\n        const validPaths = files.filter((f: any): f is string => typeof f === 'string' && f.trim() !== '')\r\n\r\n        if (validPaths.length === 0) {\r\n            return NextResponse.json({ error: \"No valid file paths received for download.\" }, { status: 400 })\r\n        }\r\n\r\n        // --- 3. File Preparation (ZIP) ---\r\n        const zip = new JSZip()\r\n        for (const filePath of validPaths) {\r\n            // content is guaranteed to be string or undefined based on fileContentsMap type\r\n            const content = fileContentsMap.get(filePath)\r\n            if (content) {\r\n                // Add the file to the zip. Use the path as the file name in the zip.\r\n                // Explicit cast to string added here to resolve potential TypeScript overload confusion\r\n                zip.file(filePath, content as string) \r\n            } else {\r\n                console.warn(`Content for path ${filePath} was requested but not found in shareRecord.files`)\r\n            }\r\n        }\r\n        \r\n        // Generate the ZIP buffer\r\n        // Note: Using 'nodebuffer' is required for Node.js environments (like Next.js API routes)\r\n        const buffer = await zip.generateAsync({ type: \"nodebuffer\" }) as Buffer\r\n        \r\n        const fileName = \"shared_files.zip\"\r\n        const contentType = \"application/zip\"\r\n\r\n        // --- 4. Final Response (Applying TypeScript ArrayBuffer Fix) ---\r\n        \r\n        // Convert the Node.js Buffer to a standard ArrayBuffer slice for compatibility with NextResponse.\r\n        const arrayBuffer = buffer.buffer.slice(\r\n            buffer.byteOffset,\r\n            buffer.byteOffset + buffer.length\r\n        ) as ArrayBuffer; \r\n\r\n        return new NextResponse(arrayBuffer, {\r\n            headers: {\r\n                \"Content-Disposition\": `attachment; filename=\"${fileName}\"`,\r\n                \"Content-Type\": contentType,\r\n                \"Content-Length\": buffer.length.toString(), \r\n            },\r\n        })\r\n\r\n    } catch (error) {\r\n        console.error(\"Shared download error:\", error)\r\n        return NextResponse.json({ error: \"Download failed due to server error\" }, { status: 500 })\r\n    }\r\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAOO,eAAe,KAAK,OAAoB;IAC3C,IAAI;QACA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;QAEvB,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,KAAK,GAAG;YAC/D,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoC,GAAG;gBAAE,QAAQ;YAAI;QAC3F;QAEA,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM,IAAA,qIAAiB;QAEtC,yEAAyE;QACzE,MAAM,cAAc,MAAM,GAAG,UAAU,CAAC,eAAe,OAAO,CAAC;YAAE;QAAI;QAErE,IAAI,CAAC,aAAa;YACd,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAgC,GAAG;gBAAE,QAAQ;YAAI;QACvF;QAEA,mBAAmB;QACnB,IAAI,YAAY,SAAS,IAAI,IAAI,SAAS,YAAY,SAAS,EAAE;YAC7D,kCAAkC;YAClC,MAAM,GAAG,UAAU,CAAC,eAAe,SAAS,CAAC;gBAAE;YAAI;YACnD,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAyB,GAAG;gBAAE,QAAQ;YAAI;QAChF;QAEA,gFAAgF;QAChF,4HAA4H;QAC5H,MAAM,aAAa,MAAM,OAAO,CAAC,YAAY,KAAK,IAAI,YAAY,KAAK,GAAG,EAAE;QAE5E,mGAAmG;QACnG,MAAM,kBAAuC,IAAI,IAC7C,WACK,MAAM,CAAC,CAAC,IAAW,KAAK,OAAO,EAAE,IAAI,KAAK,YAAY,OAAO,EAAE,OAAO,KAAK,UAC3E,GAAG,CAAC,CAAC,IAAW;gBAAC,EAAE,IAAI;gBAAE,EAAE,OAAO;aAAW;QAGtD,qCAAqC;QACrC,MAAM,aAAa,MAAM,MAAM,CAAC,CAAC,IAAwB,OAAO,MAAM,YAAY,EAAE,IAAI,OAAO;QAE/F,IAAI,WAAW,MAAM,KAAK,GAAG;YACzB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA6C,GAAG;gBAAE,QAAQ;YAAI;QACpG;QAEA,oCAAoC;QACpC,MAAM,MAAM,IAAI,kJAAK;QACrB,KAAK,MAAM,YAAY,WAAY;YAC/B,gFAAgF;YAChF,MAAM,UAAU,gBAAgB,GAAG,CAAC;YACpC,IAAI,SAAS;gBACT,qEAAqE;gBACrE,wFAAwF;gBACxF,IAAI,IAAI,CAAC,UAAU;YACvB,OAAO;gBACH,QAAQ,IAAI,CAAC,CAAC,iBAAiB,EAAE,SAAS,iDAAiD,CAAC;YAChG;QACJ;QAEA,0BAA0B;QAC1B,0FAA0F;QAC1F,MAAM,SAAS,MAAM,IAAI,aAAa,CAAC;YAAE,MAAM;QAAa;QAE5D,MAAM,WAAW;QACjB,MAAM,cAAc;QAEpB,kEAAkE;QAElE,kGAAkG;QAClG,MAAM,cAAc,OAAO,MAAM,CAAC,KAAK,CACnC,OAAO,UAAU,EACjB,OAAO,UAAU,GAAG,OAAO,MAAM;QAGrC,OAAO,IAAI,gJAAY,CAAC,aAAa;YACjC,SAAS;gBACL,uBAAuB,CAAC,sBAAsB,EAAE,SAAS,CAAC,CAAC;gBAC3D,gBAAgB;gBAChB,kBAAkB,OAAO,MAAM,CAAC,QAAQ;YAC5C;QACJ;IAEJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAsC,GAAG;YAAE,QAAQ;QAAI;IAC7F;AACJ"}}]
}